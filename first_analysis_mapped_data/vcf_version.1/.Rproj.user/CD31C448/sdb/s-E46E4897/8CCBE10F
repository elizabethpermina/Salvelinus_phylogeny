{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Junction counts manipulation\"\noutput: github_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## GitHub Documents\n\nThis is an R Markdown format used for publishing markdown documents to GitHub. When you click the **Knit** button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated.\n\n## Libraries used\n\n\n\n```{r libraries}\nif(!require(dplyr)) {\n  install.packages(\"dplyr\") }\nlibrary(dplyr)\n```\n\n\nfiles and directory structure:\n```{r files and pathways}\nfilename<-\"raw.counts.junctions.txt\"\n\n\n#file_path<-\"/Users/elizabethpermina/Documents/1_OGFfiles/OG3301/scratch/\" #set this directory\nfile_path<-\"./\"\noutput_path<-\"/Users/elizabethpermina/Documents/1_OGFfiles/OG3301/scratch/JUNCTIONS_COUNTS/\" #set output dir in this directory\njunctions_file_from_sam<-paste0(file_path, filename)\n```\nreeding files in\n```{r}\njunctions_raw_table<-read.delim(filename, sep = \"\\t\", header=FALSE) #junctions_file_from_sam changed to filename until the path is fixed\n\nnames(junctions_raw_table)<-c(\"starts\", \"ends\", \"lens\", \"junction\", \"sample\", \"counts\")\nsample_list_file<-paste0(file_path, \"sample.list\") # \nsample_list<-scan(\"sample.list\", what=\"\", sep=\"\\n\") # scan function reads from file name directly until the path is fixed\n\n```\n\n\ncheck for NA/inf in the whole data frame\n\n```{r}\napply(junctions_raw_table, 2, function(x) any(is.na(x)))\nnrow(junctions_raw_table[!is.na(junctions_raw_table$counts), ])\njunctions_raw_table <- junctions_raw_table %>% mutate(counts = replace(counts, which(is.na(counts)), 1))\n```\n\n\nsummarize number of reads (including not paired in mapping)\n\n```{r}\nread.counts.per.junction<-aggregate(junctions_raw_table$counts, by=list(junctions_raw_table$sample, junctions_raw_table$junction), FUN=\"sum\") \n```\n\n\nGet reads paired in mapping, check for NA's, sum the number of paired erads per junction\n```{r}\njunctions_raw_table.paired.reads<-junctions_raw_table %>% \n  filter(lens > 0)\n#junctions_raw_table.paired.reads <- junctions_raw_table.paired.reads %>% mutate(lens = replace(lens, which(is.na(lens)), 0))\n\napply(junctions_raw_table.paired.reads, 2, function(x) any(is.na(x)))\nwhich(is.na(junctions_raw_table.paired.reads$lens))\nmin(sqrt((!is.na(junctions_raw_table.paired.reads$lens))^2))\n\n\nread.counts.paired.reads.per.junction<-\n  aggregate(junctions_raw_table.paired.reads$counts, by=list(junctions_raw_table.paired.reads$sample, \n                                                             junctions_raw_table.paired.reads$junction), FUN=\"sum\")\n```\n\nwriting sum tables into files\n```{r}\nwrite.table(read.counts.paired.reads.per.junction, file = paste0(output_path, \"paired.reads.per.junction.csv\"), sep =\",\", quote=F)\nwrite.table(read.counts.per.junction, file = paste0(output_path, \"all.reads.per.junction.csv\"), sep =\",\", quote=F)\n```\n\n\n## Plots\n\nYou can also embed plots, for example:\n\n```{r pressure, echo=FALSE, eval=FALSE}\nplot(pressure)\n```\n\nNote that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n\n\n## Precursor files comments (commands run on NeSI Pan)\n\nraw.counts.junctions.txt is made by the following nx code \n # where samplelist is a list of samples in <font size=\"1\"> s1 s10 s11 s12 s13 s14 s15 s16 format </font> \n```{r, engine = 'bash', eval = FALSE}\nfor i in samplelist; do awk 'BEGIN {OFS=\"\\t\"} {print $0, FILENAME}' JUNCbrca*.${i}.txt | tr '.' '\\t' | cut -f1,2,3,4,5> raw.counts.junctions.$i.txt; done;\n```\n\nJUNCbrca* precursor files were made from mapped bam files via:\n\n```{r, engine = 'bash', eval = FALSE}\n#!/ust/bin/bash\nfilename=\"$1\"\n\nwhile read LINE\ndo\nchr=$(echo $LINE | awk '{print $1}')\nstart=$(echo $LINE | awk '{print $2}') #thick start, utmost left coordinate (start -74)\nend=$(echo $LINE | awk '{print $9}') #thick end, utmost right coordinate (end +74)\nname=$(echo $LINE | awk '{print $5}') # unique junction name (JUNC00000001 - JUNC00000144)\necho \"for bamfile in s1 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s2 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s3 s30 s31 s32 s33 s34 s35 s36 s37 s38 s39 s4 s40 s42 s44 s46 s48 s49 s5 s50 s52 s53 s54 s55 s57 s59 s6 s61 s62 s63 s65 s67 s69 s7 s71 s73 s75 s77 s79 s8 s81 s83 s85 s87 s89 s9 s91 s93 s95 s96; do srun samtools view /projects/uoo00095/data33/_bamfile.bam $chr:$start-$end -f 64 -F 4| cut -f 4,8,9 | sort | uniq -c > ${name}._bamfile.txt; done;\"\necho \"for bamfile in s41 s43 s45 s47 s51 s53 s56 s58 s60 s64 s66 s68 s70 s72 s74 s76 s78 s80 s82 s84 s86 s88 s90 s92 s94;\ndo srun samtools view /projects/uoo00095/data33/_bamfile.bam $chr:$start-$end -f 64 -F4 | cut -f 4,8,9 | sort | uniq -c > ${name}._bamfile.txt; done;\"\ndone < ExonStructure.thickCoordinates > samtools.bash.file.txt\n\ncat samtools.bash.file.txt | sed 's/_/$/g' > samtools.srun\n\n#samtools.srun file header for running on Pan\n\n#!/bin/bash -e\n#SBATCH --job-name SAMtools_job\n#SBATCH --account uoo00095\n#SBATCH --time 8:00:00\n#SBATCH --mem-per-cpu 8G\n#SBATCH --output SAMtools_job.%j.out # Include the job ID in the names\n#SBATCH --error SAMtools_job.%j.err # of the output and error files\n\nmodule load SAMtools\nmodule load BWA\n\n\n```\n",
    "created" : 1520388983468.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1378380637",
    "id" : "8CCBE10F",
    "lastKnownWriteTime" : 1520372094,
    "last_content_update" : 1520372094,
    "path" : "~/Documents/1_OGFfiles/OG3301/scratch/JUNCTIONS_COUNTS/Junction.counts.manipulation.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}